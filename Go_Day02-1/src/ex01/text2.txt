Сделай упражнение на go:
Упражнение 00: Поиск вещей
В качестве первого шага давайте реализуем утилиту, похожую на find-утилиту, с помощью Go. Она должна принимать путь и набор параметров командной строки, чтобы находить различные типы записей. Нас интересуют три типа записей: каталоги, обычные файлы и символические ссылки. Таким образом, мы можем запустить нашу программу следующим образом:

# Find all files/directories/symlinks recursively in directory /foo
~$ ./myFind /foo
/foo/bar
/foo/bar/baz
/foo/bar/baz/deep/directory
/foo/bar/test.txt
/foo/bar/buzz -> /foo/bar/baz
/foo/bar/broken_sl -> [broken]


или укажите -sl, -d или -f для вывода только символических ссылок, только каталогов или только файлов. Обратите внимание, что пользователь должен иметь возможность явно указать один, два или все три этих параметра, например ./myFind -f -sl /path/to/dir или ./myFind -d /path/to/other/dir.
Вам также следует реализовать ещё одну опцию — -ext (работает ТОЛЬКО при указании -f), чтобы пользователи могли печатать только файлы с определённым расширением. Расширение в этой задаче можно рассматривать как последнюю часть имени файла, если разделить его точкой. Итак,

# Find only *.go files and ignore all others.
~$ ./myFind -f -ext 'go' /go
/go/src/github.com/mycoolproject/main.go
/go/src/github.com/mycoolproject/magic.go


Вам также нужно будет разрешить символические ссылки. Поэтому, если /foo/bar/buzz — это символическая ссылка, указывающая на другое место в файловой системе, например /foo/bar/baz, выведите оба пути, разделённые ->, как в примере выше.
Ещё одна особенность символических ссылок заключается в том, что они могут быть повреждены (указывать на несуществующий файловый узел). В этом случае ваш код должен выводить [broken] вместо пути к месту назначения символической ссылки.
Файлы и каталоги, к которым у текущего пользователя нет доступа (ошибки разрешений), должны пропускаться в выводе и не вызывать ошибку во время выполнения.